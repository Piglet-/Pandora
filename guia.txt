
1) Pila de llamadas

                +-----------------+ <---- sp
                | Local2          |
                +-----------------+
                | Local1          |
                +-----------------+
                | Local0          | 
                +-----------------+ 
                | Return Address  |
                +-----------------+
                | Return Value    |
                +-----------------+ <---- fp
                | Arg1            |
                +-----------------+
                | Arg0            |
                +-----------------+
                | ...             |
                +-----------------+ 


3) Registros:

$zero                       Cero

$gp                         Global Pointer

$sp                         Stack Pointer

$fp                         Frame Pointer

$ra                         Return Address

$v0                         Return de llamadas al sistema

$a0-$a3                     Cuentas para Jumps
    
$v1, $t0-$t9, $s0-$s7   Cuentas en general

4) Plantillas

    4.1) t2 := t0 +i t1

            add Rx, Ri, Rj

    4.2) t2 := t0 +f t1

            add.s Rx, Ri, Rj

    4.3) t2 := t0 -i t1

            sub Rx, Ri, Rj

    4.4) t2:= t0 -f t1

            sub.s Rx, Ri, Rj

    4.5) t2 := t0 and t1 

            and Rx, Ri, Rj

    4.6) t2 := t0 or t1

            or Rx, Ri, Rj

    4.7) t2 := t0 > t1

            slt Rx, Rj, Ri   // pone 1 en Rx si se cumple la condicion

    4.8) t2 := t0 < t1

            slt Rx, Ri, Rj    

    4.11) t2 := t0 == t1

            seq Rx, Ri, Rj

    4.12) t2 := t0 != t1

            sne Rx, Ri, Rj

    4.13) t1 := not t0

            not Rj, Ri

    4.14) t1 := -i t0

            sub Rx, Ri, $zero
            ------
            neg Rx, Ri


    4.15) t1 := -f t0

            sub.s Rx, Ri, $zero // no estoy seguro
            ------
            neg.s Rx, Ri

    4.16) t2 := t0 <= t1

            sle Rx, Ri, Rj

    4.17) t2 := t0 >= t1

            sge Rx, Ri, Rj

    4.18) t2 := t0 *i t1

            mul Rx, Ri, Rj

    4.19) t2 := t0 *f t1

            mul.s Rx, Ri, Rj

    4.20) t2 := t0 /i t1

            div Rx, Ri, Rj

    4.21) t2 := t0 /f t1

            div.s Rx, Ri, Rj

    4.22) t2 := t0 ^ t1

            beq Rx, $zero, L2

            addi Rx, Ri, $zero

        L1: ble Rj, $zero, L3
            mul Rx, Rx, Ri
            sub Rj, Rj, 1
            b L1

        l2: addi Rx, 1, $zero

        L3:

    4.23) t2 := t0 mod t1

            div Rx, Ri, Rj
            mfhi Rx

    4.24) if a < b then goto L1 

            blt Ri, Rj, L1
            sll $0, $0, 0

    4.24) if a <= b then goto L1 

            ble Ri, Rj, L1
            sll $0, $0, 0

    4.25) goto L1

            b L1
            sll $0, $0, 0

    4.26) if not a < b then goto L1

            bgt Ri, Rj, L1
            sll $0, $0, 0

    4.27) if a > b then goto L1 

            bgt Ri, Rj, L1
            sll $0, $0, 0

 4.27) if a >= b then goto L1 

            bge Ri, Rj, L1
            sll $0, $0, 0

    4.28) if not a > b then got 

            blt Ri, Rj, L1
            sll $0, $0, 0

    4.29) if a then goto L1 

            bne Ri, $zero, L1

    4.30) if not a then goto L1

            beq Ri, $zero, L1 

------------ funciones de mips que hay que re-escribir------
    // prologo y epilogo

    4.31) writeI:

        li $v0, 1
        lw $a0, 0($sp)
        syscall

    4.32) writeF:

        li $v0, 2
        lw $f12, 0($sp)
        syscall

    4.33) writeC:

        li $v0, 11
        lw $a0, 0($sp)
        syscall

    4.34) writeB:

        li $v0, 4
        lw $a0, 0($sp)
        syscall

    4.35) writeS:

        li $v0, 4
        lw $a0, 0($sp)
        syscall

    4.36) readI:

        li $v0, 5
        syscall
        lw $Ri, $v0 

    4.37) readF:

        li $v0, 6
        syscall
        lw $Ri, $v0

    4.38) readB:

    4.39) readC:

        li $v0, 12
        syscall
        lw $Ri, $v0


------------------------------------ llamada a funciones ---------------

    4.41) t0 := call f, i  // i puede ser los arg + valor de retorno (func)
                            // i los argumentos (procedimientos)

        addi $sp, $sp, -4 // espacio para t0
        jal f
        lw Ri, 0(sp)    // guardo el valor en t0
        addi $sp, $sp, 4  // desempilo el valor de retorno
        addi $sp, $sp, i // limpio la pila

    4.42) call f, i

        addi $sp, $sp, -4 // espacio para el valor de retorno
        jal f
        addi $sp, $sp, 4  // desempilo el valor de retorno
        addi $sp, $sp, i // limpio la pila


    4.45) Return t0

        addi $sp, $sp, -4
        sw Ri, 0(sp)
        b EPILOGUE // la etiqueta de su epilogo

    4.46) t0 := t1

        lw Rj, Ri

    4.47) *t0 := t1

        sw Rj, 0(Ri)

    4.48) t0 := *t1

        lw Ri, 0(Rj)

    4.49) PARAM t0 

        addi $sp, $sp, -4
        sw Ri, 0($sp)

    4.50) CLEANUP i

        addi $sp, $sp, i

4.44) PROLOGUE i
        
        addi $sp, $sp, -4
        sw $ra, 0($sp)
        addi $sp, $sp, -4
        sw $fp, 0($sp)
        lw $sp, $fp
        sub $sp, $sp, i

4.43) EPILOGUE i

        // epilogo ejemplo de la clase
        sw Ri, 8($fp)
        move $sp, $fp
        lw $fp, 0($sp)
        addi $sp, $sp, 4
        b 0($sp)